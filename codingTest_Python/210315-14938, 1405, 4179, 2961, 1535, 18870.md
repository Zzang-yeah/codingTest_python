# 210312-14938, 1405, 4179, 2961, 1535, 18870

## 1. 백준 14938번. 서강 그라운드

https://www.acmicpc.net/problem/14938

```python
INF=int(1e9)

n,m,r=map(int,input().split())
items=list(map(int,input().split()))
graph=[[INF]*(n+1) for _ in range(n+1)]

for a in range(1, n+1):
    for b in range(1, n+1):
        if a==b:
            graph[a][b]=0

for _ in range(r):
    a,b,c=map(int,input().split())
    graph[a][b] = c
    graph[b][a] = c

for k in range(1, n+1):
    for a in range(1, n+1):
        for b in range(1, n+1):
            graph[a][b]=min(graph[a][b], graph[a][k]+graph[k][b])

result=0
for i in range(1, n+1):
    now=0
    for j in range(1,n+1):
        if graph[i][j]<=m:
            now+=items[j-1]
    result=max(result,now)

print(result)
```

플로이드 워셜알고리즘을 사용해서 모든 노드에서 모든 노드로 가는 최소 비용을 구하고 for문을 돌려서 i번째 노드에서 j번째 노드로 가는 비용이 수색거리와 같거나 작으면 j번째 노드의 아이템을 얻을 수 있다는 것이므로 now라는 변수에 i번째 노드에 예은이가 떨어졌을때의 얻을 수 있는 아이템들을 더해줬다. result를 i번째 노드 탐색이 끝날때마다 갱신해주면 끝!

