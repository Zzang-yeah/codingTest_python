# chapter8. 다이나믹 프로그래밍

1. 다이나믹 프로그래밍

   - 중복되는 연산을 줄이자

     메모리 공간을 약간 더 사용하면서 연산 속도는 비약적으로 증가시킬 수 있는 방법

     아래의 두가지 조건을 충족하면 사용가능

     1. 큰 문제를 작은 문제로 나눌 수 있다.
     2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

     =>다이나믹 프로그래밍이란 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법

     분할정복문제와 다이나믹 프로그래밍의 차이점 : DP는 문제들이 서로 영향을 미친다.

     메모이제이션(=캐싱) : DP구현방법 중 하나, 한번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법

     ```python
     #메모이제이션 기법을 사용하여 구현한 피보나치 수열(재귀)
     d=[0]*100
     
     def fibo(x):
         if x==1 or x==2:
             return 1
         if d[x]!=0:
             return d[x]
         d[x]=fibo(x-1)+fibo(x-2)
         return d[x]
     ```

     ```python
     #피보나치 수열(반복)
     d=[0]*100
     
     d[1]=1
     d[2]=1
     n=99
     
     for i in range(3, n+1):
         d[i]=d[i-1]+d[i-2]
     ```

     탑다운 방식 : 큰 문제를 해결하기 위해 작은 문제를 호출 ex)재귀

     보텀업 방식 : 작은 문제부터 차근차근 답을 도출 ex)반복

2. 실전문제 : 1로 만들기

   정수 x가 주어질 때 정수 x에 사용할 수 있는 연산은 다음과 같이 4가지

   - x가 5로 나누어떨어지면, 5로 나눈다.
   - x가 3으로 나누어떨어지면, 3으로 나눈다.
   - x가 2로 나누어떨어지면, 2로 나눈다.
   - x에서 1을 뺀다

   정수 x가 주어졌을때 연산 4개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값은?

   ```python
   #대박 동빈씨는 천재;
   x=int(input())
   
   d=[0]*(x+1)
   
   for i in range(2, x+1):
       d[i]=d[i-1]+1
       if i%2==0:
           d[i]=min(d[i],d[i//2]+1)
       if i%3==0:
           d[i]=min(d[i],d[i//3]+1)
       if i%5==0:
           d[i]=min(d[i],d[i//5]+1)
   ```

3. 실전문제 : 개미 전사

   메뚜기 마을에는 식량창고가 일직선으로 여러개 이어져 있음

   식량창고에는 정해진 수의 식량을 저장하고 있고 개미는 선택적으로 약탈하여 식량을 빼앗을 예정

   *서로 인접한 식량창고가 공격받으면 안됨->최소 한칸 이상 떨어진 식량창고 약탈해야함

   이때 개미가 얻을 수 있는 식량의 최댓값은?

   ```python
   n=int(input())
   array=list(map(int,input().split()))
   
   d=[0]*100
   
   d[0]=array[0]
   d[1]=max(array[0], array[1])
   for i in range(2,n):
       d[i]=max(d[i-1], d[i-2]+array[i])
   ```

4. 실전문제 : 바닥 공사

   가로 길이 : N, 세로 길이 : 2인 직사각형 형태의 얆은 바닥

   1, 2/ 2, 1/ 2, 2의 덮개를 이용해 바닥을 채움

   바닥을 채우는 모든 경우의 수?

   ```python
   n=int(input())
   
   d=[0]*1001
   
   d[1]=1
   d[2]=3
   for i in range(3, n+1):
       d[i]=(d[i-1]+2*d[i-2]%796796) #결과값이 매우 커질 수 있기 때문에 나눠줌
   ```

   